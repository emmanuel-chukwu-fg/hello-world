kubectl get pods --output=jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | xargs -I {} kubectl exec {} -- dotnet --info
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name --no-headers=true | \
  xargs -I {} bash -c 'echo -n "{}," && kubectl exec {} -- dotnet --version --namespace={} 2>/dev/null' | \
  awk '{print $1,$NF}' OFS=',' > dotnet_versions.csv


kubectl get pods --all-namespaces -o jsonpath="{range .items[*]}{@.metadata.namespace},{@.metadata.name}{'\n'}{end}" | awk -F, '{system("echo -n "$1","$2","; kubectl exec -n "$1" "$2" -- dotnet --version 2>/dev/null")}' | tee pods_dotnet_versions.csv
kubectl get pods --all-namespaces -o jsonpath="{range .items[*]}{@.metadata.namespace},{@.metadata.name}{'\n'}{end}" | awk -F, '{system("echo -n "$1","$2","; kubectl exec -n "$1" "$2" -- dotnet --version 2>/dev/null")}' | tee pods_dotnet_versions.csv
kubectl get pods --all-namespaces -o jsonpath="{range .items[*]}{@.metadata.namespace} {@.metadata.name}{'\n'}{end}" | xargs -n2 sh -c 'dotnet_version=$(kubectl exec -n $0 $1 -- sh -c "command -v dotnet && dotnet --version" 2>/dev/null); if [ -n "$dotnet_version" ]; then echo "$0,$1,$dotnet_version"; fi' | tee pods_dotnet_versions.csv


import subprocess
import json

# Define your clusters with relevant details.
CLUSTERS = [
    {"name": "non-prod-buying", "project": "project1", "context": "context1"},
    # ... other clusters ...
]

def switch_context(cluster_info):
    """
    Switches the kubectl context to the specified context.
    """
    # Extract the context from the cluster information dictionary.
    context = cluster_info['context']
    # Command to switch kubectl context to the specified context.
    cmd = ['kubectl', 'config', 'use-context', context]
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = proc.communicate()

    # If there's an error switching the context, log it and return False.
    if proc.returncode != 0:
        print(f"Error switching to context {context}: {err.decode()}")
        return False

    # Context switch successful.
    print(f"Switched to context {context}")
    return True

def get_ingresses():
    """
    Retrieves all Ingress resources from the current kubectl context.
    """
    cmd = "kubectl get ingress --all-namespaces -o json"
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    out, err = proc.communicate()

    if proc.returncode != 0:
        print(f"Error getting ingresses: {err.decode()}")
        return []
    
    print(f"Ingresses retrieved: {out.decode()}")  # Print the output for verification
    return json.loads(out.decode())['items']

def build_urls(ingresses):
    """
    Constructs URLs for each service based on the ingress data.
    """
    urls = []
    for ingress in ingresses:
        annotations = ingress['metadata'].get('annotations', {})
        if 'nginx.ingress.kubernetes.io/rewrite-target' in annotations:
            base_path = annotations['nginx.ingress.kubernetes.io/rewrite-target']
        else:
            base_path = '/'
        
        for rule in ingress.get('spec', {}).get('rules', []):
            host = rule.get('host', '')
            for path in rule.get('http', {}).get('paths', []):
                urls.append(f"https://{host}{base_path}health")
    
    print(f"URLs constructed: {urls}")  # Print the URLs for verification
    return urls

def check_endpoints(urls):
    """
    Checks each endpoint to ensure it's up and running.
    """
    for url in urls:
        cmd = f"curl -k -s -o /dev/null -w '%{{http_code}}' {url}"
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        out, err = proc.communicate()

        if out.strip() == b"200":
            print(f"Success: {url} is working fine.")
        else:
            print(f"Error reaching {url}: {out.decode()} - {err.decode()}")

def main():
    """
    Main function to iterate over all clusters and check the health of their ingresses.
    """
    for cluster_info in CLUSTERS:
        if switch_context(cluster_info):
            print(f"Checking ingresses in context {cluster_info['context']} for cluster {cluster_info['name']}")
            ingresses = get_ingresses()
            urls = build_urls(ingresses)
            check_endpoints(urls)
        else:
            print(f"Skipping SSL check for context {cluster_info['context']} in cluster {cluster_info['name']}")

if __name__ == "__main__":
    main()
